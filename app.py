'''Name:- MEET RATWANI
I HAVE WRITTEN COMMENTS ALSO WHERE I HAVE USED AI TO GENERATE THE CODE.
ROLL NO - 32 
FRONTEND IS 70% GENERATED BY AI. BACKEND IS 10% GENERATED BY AI.
CLASS - 11 SCI 
YOUTUBE LINK :- https://www.youtube.com/watch?v=lhh7_6A5sXE&list=PL4P8sY6zvjk6ef4lpm6XiwJVRahLCp6DI&index=16
I HAVE REFERED THIS LINK TO LEARN LOGIC AND BACKEND I IS MADE ON TKINTER BUT I HAVE MADE WEBSITE FROM FLASK 
BARCODE GENERATION PART IS MAINLY DONE BY AI WITH SOME MODIFICATIONS AND DEBUGGING BY ME
FILE MIGRATE_JSON AND MODELS .PY IS WRITTEN 30 TO 40 % BY AI AND MANUAL DEBUGGING AND MODIFICATIONS BY ME 
AI IS USED TO CONNECT TO MAKE DATA RESERVED BEACUSE WHEN WEBISTE SERVER IS CLOSE DATA HAS BEEN LOST SO SOLUTION WAS FIND BY AI 

THANK YOU
'''
import os
from datetime import datetime, date, timezone, timedelta
import json

IST = timezone(timedelta(hours=5, minutes=30))

def now_ist():
    """Get current datetime in IST timezone."""
    return datetime.now(IST)
from pathlib import Path
import csv
from io import StringIO, BytesIO

from functools import wraps
from werkzeug.utils import secure_filename
from dotenv import load_dotenv

from flask import Flask, render_template, request, redirect, url_for, flash, make_response, session, send_file
import firebase_admin
from firebase_admin import credentials, auth


load_dotenv()

# Database ke liye 
from models import db, User, StoreSettings, Product, Supplier, Invoice, InvoiceItem, Expense, StockTransaction
from config import config

app = Flask(__name__)


env = os.environ.get('FLASK_ENV', 'development')
app.config.from_object(config[env])

db.init_app(app)


try:
    
    firebase_creds_env = os.environ.get("FIREBASE_CREDENTIALS")
    cred = None

    if firebase_creds_env:
        
        try:
            
            cred_dict = json.loads(firebase_creds_env)
            cred = credentials.Certificate(cred_dict)
            print("[OK] Firebase initialized from environment variable")
        except json.JSONDecodeError as e:
            print(f"[WARN] Failed to parse FIREBASE_CREDENTIALS: {e}")

    
    if not cred:
        cred_path = Path("firebase_credentials.json")
        if cred_path.exists() and cred_path.stat().st_size > 10:
            cred = credentials.Certificate(str(cred_path))
            print("[OK] Firebase initialized from local file")
        else:
            print("[WARN] Firebase credentials file not found")

    if cred:
        firebase_admin.initialize_app(cred)
        FIREBASE_ENABLED = True
    else:
        FIREBASE_ENABLED = False
        print("[WARN] Firebase not initialized - running in local mode")

except Exception as e:
    FIREBASE_ENABLED = False
    print(f"[WARN] Firebase initialization failed: {e} - running in local mode")


# Jinja2 Template Filters for IST timezone conversion
@app.template_filter('to_ist')
def to_ist_filter(dt):
    """Convert a datetime to IST timezone."""
    if dt is None:
        return None
    # If datetime is naive (no timezone), assume it's UTC
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    # Convert to IST
    ist_dt = dt.astimezone(IST)
    return ist_dt

@app.template_filter('format_ist_time')
def format_ist_time_filter(dt, fmt='%I:%M %p'):
    """Format datetime in IST timezone with given format."""
    if dt is None:
        return '-'
    ist_dt = to_ist_filter(dt)
    return ist_dt.strftime(fmt)

@app.template_filter('format_ist_datetime')
def format_ist_datetime_filter(dt, fmt='%d-%m-%Y %I:%M %p'):
    """Format datetime in IST timezone with date and time."""
    if dt is None:
        return '-'
    ist_dt = to_ist_filter(dt)
    return ist_dt.strftime(fmt) + ' IST'


def login_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not session.get("logged_in"):
            return redirect(url_for("login", next=request.url))
        return f(*args, **kwargs)
    return decorated_function


def get_current_user_id():
    """Get the current logged-in user's ID from session."""
    return session.get("user_id", "default_user")


def get_or_create_user(user_id: str, email: str = None) -> User:
    """Get existing user or create new one."""
    user = User.query.get(user_id)
    if not user:
        user = User(id=user_id, email=email or f"{user_id}@example.com")
        db.session.add(user)
        db.session.commit()
    return user



def get_store_settings() -> dict:
    """Get store settings for current user."""
    user_id = get_current_user_id()
    user = get_or_create_user(user_id)
    
    settings = StoreSettings.query.filter_by(user_id=user_id).first()
    
    if not settings:
        settings = StoreSettings(
            user_id=user_id,
            store_name="Managekarlo",
            address="",
            phone="",
            email="",
        )
        db.session.add(settings)
        db.session.commit()
    
    return {
        "store_name": settings.store_name or "Managekarlo",
        "address": settings.address or "",
        "phone": settings.phone or "",
        "email": settings.email or "",
        "logo_url": url_for("get_store_logo") if settings.logo_data else "",
    }


def save_store_settings(data: dict, logo_file=None) -> None:
    """Save store settings for current user."""
    user_id = get_current_user_id()
    user = get_or_create_user(user_id)
    
    settings = StoreSettings.query.filter_by(user_id=user_id).first()
    
    if not settings:
        settings = StoreSettings(user_id=user_id)
        db.session.add(settings)
    
    settings.store_name = data.get("store_name", "Managekarlo")
    settings.address = data.get("address", "")
    settings.phone = data.get("phone", "")
    settings.email = data.get("email", "")
    
    
    if logo_file and logo_file.filename:
        settings.logo_data = logo_file.read()
        settings.logo_filename = secure_filename(logo_file.filename)
        settings.logo_mimetype = logo_file.mimetype
    
    db.session.commit()


def generate_invoice_number() -> str:
    """Generate incremental invoice number: RS-<year>-0001 style."""
    user_id = get_current_user_id()
    settings = StoreSettings.query.filter_by(user_id=user_id).first()
    
    if not settings:
        user = get_or_create_user(user_id)
        settings = StoreSettings(user_id=user_id, store_name="Managekarlo")
        db.session.add(settings)
    
    settings.invoice_counter += 1
    db.session.commit()
    
    year = now_ist().year
    return f"RS-{year}-{settings.invoice_counter:04d}"




def get_products() -> list:
    """Get all products for current user."""
    user_id = get_current_user_id()
    products = Product.query.filter_by(user_id=user_id).all()
    return products


def find_product(product_id: int) -> Product:
    """Find product by ID for current user."""
    user_id = get_current_user_id()
    return Product.query.filter_by(id=product_id, user_id=user_id).first()


def create_product(data: dict) -> Product:
    """Create a new product."""
    user_id = get_current_user_id()
    user = get_or_create_user(user_id)
    
    sku = data.get("sku", "").strip() or f"SKU-{now_ist().timestamp()}"
    barcode = data.get("barcode", "").strip() or sku
    
    product = Product(
        user_id=user_id,
        name=data.get("name", "").strip(),
        description=data.get("description", "").strip(),
        sku=sku,
        barcode=barcode,
        category=data.get("category", "").strip(),
        brand=data.get("brand", "").strip(),
        unit_price=float(data.get("unit_price") or 0),
        cost_price=float(data.get("cost_price") or 0),
        stock_quantity=float(data.get("stock_quantity") or 0),
        min_stock_level=float(data.get("min_stock_level") or 0),
        supplier_id=int(data.get("supplier_id")) if data.get("supplier_id") else None,
    )
    
    db.session.add(product)
    db.session.commit()
    
    return product


def update_product(product: Product, data: dict) -> None:
    """Update an existing product."""
    sku = (data.get("sku", "") or "").strip() or product.sku or f"SKU-{product.id}"
    barcode = (data.get("barcode", "") or "").strip() or product.barcode or sku
    
    product.name = data.get("name", "").strip()
    product.description = data.get("description", "").strip()
    product.sku = sku
    product.barcode = barcode
    product.category = data.get("category", "").strip()
    product.brand = data.get("brand", "").strip()
    product.unit_price = float(data.get("unit_price") or 0)
    product.cost_price = float(data.get("cost_price") or 0)
    product.stock_quantity = float(data.get("stock_quantity") or 0)
    product.min_stock_level = float(data.get("min_stock_level") or 0)
    product.supplier_id = int(data.get("supplier_id")) if data.get("supplier_id") else None
    
    db.session.commit()


def record_stock_transaction(product_id: int, tx_type: str, quantity: float, reference_id: str = "", notes: str = "") -> None:
    """Record a stock transaction."""
    user_id = get_current_user_id()
    
    transaction = StockTransaction(
        user_id=user_id,
        product_id=product_id,
        transaction_type=tx_type,
        quantity=float(quantity or 0),
        reference_id=reference_id,
        notes=notes,
    )
    
    db.session.add(transaction)
    db.session.commit()


def adjust_stock(product_id: int, delta: float, tx_type: str, reference_id: str = "", notes: str = "") -> None:
    """Adjust product stock and record transaction."""
    product = find_product(product_id)
    if not product:
        return
    
    product.stock_quantity += float(delta or 0)
    record_stock_transaction(product_id, tx_type, delta, reference_id, notes)
    db.session.commit()



@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        id_token = request.form.get("id_token")
        
        if id_token and FIREBASE_ENABLED:
            try:
                decoded_token = auth.verify_id_token(id_token)
                user_id = decoded_token['uid']
                email = decoded_token.get('email', '')
                
                user = get_or_create_user(user_id, email)
                user.last_login = now_ist()
                db.session.commit()
                
                session["logged_in"] = True
                session["user_id"] = user_id
                session["email"] = email
                
                next_url = request.args.get("next") or url_for("invoice_list")
                return redirect(next_url)
            except Exception as e:
                print(f"Firebase auth error: {e}")
                flash("Authentication failed. Please try again.", "error")
        else:
            if not FIREBASE_ENABLED:
                flash("Firebase not configured. Secure login required.", "error")
            else:
                flash("Invalid authentication method.", "error")
            
            return redirect(url_for("login"))

    try:
        settings = StoreSettings.query.first()
        if settings:
            store = {
                "store_name": settings.store_name or "Managekarlo",
                "address": settings.address or "",
                "phone": settings.phone or "",
                "email": settings.email or "",
                "logo_url": "",
            }
        else:
            store = {
                "store_name": "Managekarlo",
                "address": "",
                "phone": "",
                "email": "",
                "logo_url": "",
            }
    except:
        store = {"store_name": "Managekarlo", "address": "", "phone": "", "email": "", "logo_url": ""}
    
    return render_template("login.html", store=store, firebase_enabled=FIREBASE_ENABLED)


@app.route("/logout")
def logout():
    email = session.get("email", "User")
    session.clear()
    flash(f"You have been logged out.", "info")
    return redirect(url_for("login"))


@app.route("/")
@login_required
def invoice_list():
    store = get_store_settings()
    user_id = get_current_user_id()
    
    search_phone = (request.args.get("phone") or "").strip()
    search_date = (request.args.get("date") or "").strip()
    

    query = Invoice.query.filter_by(user_id=user_id)
    
    if search_phone:
        query = query.filter(Invoice.customer_phone.contains(search_phone))
    
    if search_date:
        try:
            date_obj = datetime.strptime(search_date, "%Y-%m-%d").date()
            query = query.filter(Invoice.invoice_date == date_obj)
        except ValueError:
            pass
    
    invoices = query.order_by(Invoice.created_at.desc()).all()
    
    return render_template(
        "invoice_list.html",
        store=store,
        invoices=invoices,
        search_phone=search_phone,
        search_date=search_date,
    )


@app.route("/invoices/export")
@login_required
def export_invoices():
    """Export all invoices as a CSV file."""
    user_id = get_current_user_id()
    invoices = Invoice.query.filter_by(user_id=user_id).order_by(Invoice.created_at.desc()).all()
    
    output = StringIO()
    writer = csv.writer(output)
    
    writer.writerow(["Invoice #", "Date & time", "Invoice date", "Customer", "Phone", "Total", "Payment mode"])
    for inv in invoices:
        writer.writerow([
            inv.invoice_number,
            inv.created_at.strftime("%Y-%m-%d %H:%M:%S"),
            inv.invoice_date.strftime("%Y-%m-%d"),
            inv.customer_name or "-",
            inv.customer_phone or "-",
            f"{inv.total:.2f}",
            inv.payment_mode or "-",
        ])
    
    csv_data = output.getvalue()
    output.close()
    
    response = make_response(csv_data)
    response.headers["Content-Type"] = "text/csv; charset=utf-8"
    response.headers["Content-Disposition"] = "attachment; filename=invoices-all.csv"
    return response


@app.route("/invoice/new", methods=["GET", "POST"])
@login_required
#INVOICE 
def new_invoice():
    store = get_store_settings()
    
    if request.method == "POST":
        user_id = get_current_user_id()
        form = request.form
        now = now_ist()
        invoice_date_str = form.get("invoice_date") or now.strftime("%Y-%m-%d")
        invoice_date = datetime.strptime(invoice_date_str, "%Y-%m-%d").date()
        invoice_number = generate_invoice_number()
        
        # Line items (arrays)
        descriptions = form.getlist("item_description[]")
        quantities = form.getlist("item_quantity[]")
        unit_prices = form.getlist("item_unit_price[]")
        product_ids = form.getlist("item_product_id[]")
        
        items = []
        subtotal = 0.0
        
        for desc, qty_str, price_str, product_id in zip(descriptions, quantities, unit_prices, product_ids):
            if not desc.strip():
                continue
            try:
                qty = float(qty_str or 0)
                price = float(price_str or 0)
            except ValueError:
                qty = 0.0
                price = 0.0
            line_total = qty * price
            subtotal += line_total
            
            item = InvoiceItem(
                description=desc.strip(),
                quantity=qty,
                unit_price=price,
                line_total=line_total,
                product_id=int(product_id) if product_id else None,
            )
            items.append(item)
        
        try:
            discount = float(form.get("discount") or 0)
        except ValueError:
            discount = 0.0
        try:
            tax = float(form.get("tax") or 0)
        except ValueError:
            tax = 0.0
        
        total = subtotal - discount + tax
        
        # New invoice ke liye
        invoice = Invoice(
            user_id=user_id,
            invoice_number=invoice_number,
            invoice_date=invoice_date,
            customer_name=form.get("customer_name", "").strip(),
            customer_phone=form.get("customer_phone", "").strip(),
            customer_address=form.get("customer_address", "").strip(),
            customer_gstin=form.get("customer_gstin", "").strip(),
            subtotal=subtotal,
            discount=discount,
            tax=tax,
            total=total,
            payment_mode=form.get("payment_mode"),
            payment_reference=form.get("payment_reference", "").strip(),
            notes=form.get("notes", "").strip(),
        )
        
        db.session.add(invoice)
        db.session.flush()  
        
        
        for item in items:
            item.invoice_id = invoice.id
            db.session.add(item)
        
        db.session.commit()
        

        for item in items:
            if item.product_id and item.quantity > 0:
                adjust_stock(
                    item.product_id,
                    -item.quantity,
                    "sale",
                    reference_id=str(invoice.id),
                    notes=f"Invoice {invoice_number}"
                )
        
        flash("Invoice created successfully.", "success")
        return redirect(url_for("invoice_view", invoice_id=invoice.id))
    
    today = now_ist().strftime("%Y-%m-%d")
    products = get_products()
    return render_template("new_invoice.html", store=store, today=today, products=products)


@app.route("/invoice/<int:invoice_id>")
@login_required
def invoice_view(invoice_id: int):
    store = get_store_settings()
    user_id = get_current_user_id()
    invoice = Invoice.query.filter_by(id=invoice_id, user_id=user_id).first()
    
    if not invoice:
        flash("Invoice not found.", "error")
        return redirect(url_for("invoice_list"))
    
    return render_template("invoice_view.html", store=store, invoice=invoice)


@app.route("/invoice/<int:invoice_id>/delete", methods=["POST"])
@login_required
def delete_invoice(invoice_id: int):
    """Delete a single invoice by id."""
    user_id = get_current_user_id()
    invoice = Invoice.query.filter_by(id=invoice_id, user_id=user_id).first()
    
    if not invoice:
        flash("Invoice not found.", "error")
    else:
        db.session.delete(invoice)
        db.session.commit()
        flash("Invoice deleted successfully.", "success")
    
    return redirect(url_for("invoice_list"))


@app.route("/invoice/<int:invoice_id>/convert-credit-to-cash", methods=["POST"])
@login_required
def convert_credit_to_cash(invoice_id: int):
    """Convert an invoice payment mode from CREDIT to CASH."""
    user_id = get_current_user_id()
    invoice = Invoice.query.filter_by(id=invoice_id, user_id=user_id).first()
    
    if not invoice:
        flash("Invoice not found.", "error")
        return redirect(url_for("invoice_list"))
    
    if (invoice.payment_mode or "").upper() != "CREDIT":
        flash("Invoice is not in CREDIT payment mode.", "error")
        return redirect(url_for("invoice_view", invoice_id=invoice_id))
    
    invoice.payment_mode = "CASH"
    
    timestamp = now_ist().strftime("%Y-%m-%d %H:%M:%S")
    conversion_note = f"[Converted from CREDIT to CASH on {timestamp}]"
    if invoice.notes:
        invoice.notes = invoice.notes + "\n" + conversion_note
    else:
        invoice.notes = conversion_note
    
    db.session.commit()
    flash("Invoice payment changed from CREDIT to CASH.", "success")
    
    return redirect(url_for("invoice_view", invoice_id=invoice_id))


@app.route("/invoice/<int:invoice_id>/download")
@login_required
def download_invoice(invoice_id: int):
    store = get_store_settings()
    user_id = get_current_user_id()
    invoice = Invoice.query.filter_by(id=invoice_id, user_id=user_id).first()
    
    if not invoice:
        flash("Invoice not found.", "error")
        return redirect(url_for("invoice_list"))
    
    html = render_template("invoice_view.html", store=store, invoice=invoice)
    response = make_response(html)
    filename = f"invoice-{invoice.invoice_number}.html"
    response.headers["Content-Type"] = "text/html; charset=utf-8"
    response.headers["Content-Disposition"] = f"attachment; filename={filename}"
    return response


@app.route("/expenses", methods=["GET", "POST"])
@login_required
def expenses():
    store = get_store_settings()
    user_id = get_current_user_id()
    
    if request.method == "POST":
        form = request.form
        date_str = form.get("date") or now_ist().strftime("%Y-%m-%d")
        expense_date = datetime.strptime(date_str, "%Y-%m-%d").date()
        
        expense = Expense(
            user_id=user_id,
            date=expense_date,
            description=form.get("description", "").strip(),
            category=form.get("category", "").strip(),
            amount=float(form.get("amount") or 0),
        )
        
        db.session.add(expense)
        db.session.commit()
        flash("Expense recorded.", "success")
        return redirect(url_for("expenses"))
    
    all_expenses = Expense.query.filter_by(user_id=user_id).order_by(Expense.date.desc()).all()
    today = now_ist().strftime("%Y-%m-%d")
    return render_template("expenses.html", store=store, expenses=all_expenses, today=today)


@app.route("/expenses/export")
@login_required
def export_expenses():
    """Export all expenses as a CSV file."""
    user_id = get_current_user_id()
    all_expenses = Expense.query.filter_by(user_id=user_id).order_by(Expense.date.desc()).all()
    
    output = StringIO()
    writer = csv.writer(output)
    
    writer.writerow(["Date", "Description", "Category", "Amount"])
    for exp in all_expenses:
        writer.writerow([
            exp.date.strftime("%Y-%m-%d"),
            exp.description,
            exp.category or "-",
            f"{exp.amount:.2f}",
        ])
    
    csv_data = output.getvalue()
    output.close()
    
    response = make_response(csv_data)
    response.headers["Content-Type"] = "text/csv; charset=utf-8"
    response.headers["Content-Disposition"] = "attachment; filename=expenses-all.csv"
    return response


@app.route("/reports")
@login_required
def reports():
    store = get_store_settings()
    user_id = get_current_user_id()
    
    today_str = now_ist().strftime("%Y-%m-%d")
    current_month_str = now_ist().strftime("%Y-%m")
    
    period = request.args.get("period") or "daily"
    selected_date = request.args.get("date") or today_str
    selected_month = request.args.get("month") or current_month_str
    
    if period == "monthly":
        try:
            year, month = map(int, selected_month.split("-"))
        except ValueError:
            year, month = now_ist().year, now_ist().month
        
        # AI Generated part of code
        from sqlalchemy import extract
        invoices = Invoice.query.filter_by(user_id=user_id).filter(
            extract('year', Invoice.invoice_date) == year,
            extract('month', Invoice.invoice_date) == month
        ).all()
        
        
        expenses_data = Expense.query.filter_by(user_id=user_id).filter(
            extract('year', Expense.date) == year,
            extract('month', Expense.date) == month
        ).all()
        
        label = f"{year}-{month:02d} (Monthly)"
    else:
        # Daily report
        try:
            date_obj = datetime.strptime(selected_date, "%Y-%m-%d").date()
        except ValueError:
            date_obj = date.today()
            selected_date = date_obj.strftime("%Y-%m-%d")
        
        invoices = Invoice.query.filter_by(user_id=user_id, invoice_date=date_obj).all()
        expenses_data = Expense.query.filter_by(user_id=user_id, date=date_obj).all()
        label = f"{selected_date} (Daily)"
    
    sales_total = sum(inv.total for inv in invoices)
    expenses_total = sum(exp.amount for exp in expenses_data)
    net_total = sales_total - expenses_total
    
    invoice_count = len(invoices)
    expense_count = len(expenses_data)
    
    # SUMMARY
    if invoice_count == 0 and expense_count == 0:
        ai_summary = "No financial activity recorded for this period."
    else:
        trend = "balanced"
        if net_total > 0:
            trend = "profitable"
        elif net_total < 0:
            trend = "loss-making"
        
        ai_summary = (
            f"AI summary: For {label}, total sales are Rs. {sales_total:.2f} "
            f"across {invoice_count} invoice(s), with expenses of Rs. {expenses_total:.2f}. "
            f"The period is {trend} with a net of Rs. {net_total:.2f}. "
        )
        if expenses_total > 0:
            ai_summary += "Consider reviewing infrastructure and operational costs to optimize profit."
        else:
            ai_summary += "No expenses recorded, so all sales are currently counted as profit."
    
    report = {
        "label": label,
        "sales_total": sales_total,
        "expenses_total": expenses_total,
        "net_total": net_total,
        "invoice_count": invoice_count,
        "expense_count": expense_count,
        "invoices": invoices,
        "expenses": expenses_data,
        "ai_summary": ai_summary,
    }
    
    return render_template(
        "reports.html",
        store=store,
        report=report,
        period=period,
        selected_date=selected_date,
        selected_month=selected_month,
    )


@app.route("/reports/export")
#AI GENERATED PART OVER
@login_required
def export_report():
    """Export the current report as CSV."""
    user_id = get_current_user_id()
    
    today_str = now_ist().strftime("%Y-%m-%d")
    current_month_str = now_ist().strftime("%Y-%m")
    
    period = request.args.get("period") or "daily"
    selected_date = request.args.get("date") or today_str
    selected_month = request.args.get("month") or current_month_str
    
    if period == "monthly":
        try:
            year, month = map(int, selected_month.split("-"))
        except ValueError:
            year, month = now_ist().year, now_ist().month
        
        from sqlalchemy import extract
        invoices = Invoice.query.filter_by(user_id=user_id).filter(
            extract('year', Invoice.invoice_date) == year,
            extract('month', Invoice.invoice_date) == month
        ).all()
        
        expenses_data = Expense.query.filter_by(user_id=user_id).filter(
            extract('year', Expense.date) == year,
            extract('month', Expense.date) == month
        ).all()
        
        label = f"{year}-{month:02d} (Monthly)"
        filename_period = selected_month
    else:
        try:
            date_obj = datetime.strptime(selected_date, "%Y-%m-%d").date()
        except ValueError:
            date_obj = date.today()
            selected_date = date_obj.strftime("%Y-%m-%d")
        
        invoices = Invoice.query.filter_by(user_id=user_id, invoice_date=date_obj).all()
        expenses_data = Expense.query.filter_by(user_id=user_id, date=date_obj).all()
        label = f"{selected_date} (Daily)"
        filename_period = selected_date
    
    sales_total = sum(inv.total for inv in invoices)
    expenses_total = sum(exp.amount for exp in expenses_data)
    net_total = sales_total - expenses_total
    #AI GENERATED 
    output = StringIO()
    writer = csv.writer(output)
    
    
    writer.writerow(["Report", label])
    writer.writerow(["Total sales", f"{sales_total:.2f}"])
    writer.writerow(["Total expenses", f"{expenses_total:.2f}"])
    writer.writerow(["Net (sales - expenses)", f"{net_total:.2f}"])
    writer.writerow([])
    #AI GENERATED PART OVER
    # Invoices section
    writer.writerow(["Invoices"])
    writer.writerow(["Invoice #", "Date", "Customer", "Total", "Payment mode"])
    for inv in invoices:
        writer.writerow([
            inv.invoice_number,
            inv.invoice_date.strftime("%Y-%m-%d"),
            inv.customer_name or "-",
            f"{inv.total:.2f}",
            inv.payment_mode or "-",
        ])
    
    writer.writerow([])
    
    writer.writerow(["Expenses"])
    writer.writerow(["Date", "Description", "Category", "Amount"])
    for exp in expenses_data:
        writer.writerow([
            exp.date.strftime("%Y-%m-%d"),
            exp.description,
            exp.category or "-",
            f"{exp.amount:.2f}",
        ])
    
    csv_data = output.getvalue()
    output.close()
    
    filename = f"report-{period}-{filename_period}.csv"
    
    response = make_response(csv_data)
    response.headers["Content-Type"] = "text/csv; charset=utf-8"
    response.headers["Content-Disposition"] = f"attachment; filename={filename}"
    return response


@app.route("/settings", methods=["GET", "POST"])
@login_required
def settings():
    if request.method == "POST":
        data = {
            "store_name": request.form.get("store_name", "").strip(),
            "address": request.form.get("address", "").strip(),
            "phone": request.form.get("phone", "").strip(),
            "email": request.form.get("email", "").strip(),
        }
        
        logo_file = request.files.get("logo_file")
        save_store_settings(data, logo_file)
        
        flash("Store settings saved.", "success")
        return redirect(url_for("settings"))
    
    store = get_store_settings()
    return render_template("settings.html", store=store)
#AI GENERATED 

@app.route("/store-logo")
def get_store_logo():
    """Serve store logo from database."""
    user_id = session.get("user_id", "default_user")
    settings = StoreSettings.query.filter_by(user_id=user_id).first()
    
    if settings and settings.logo_data:
        return send_file(
            BytesIO(settings.logo_data),
            mimetype=settings.logo_mimetype or 'image/png',
            as_attachment=False,
            download_name=settings.logo_filename or 'logo.png'
        )
#AI GENERATED PART OVER   
    # Return 404 if no logo
    from flask import abort
    abort(404)




@app.route("/products")
@login_required
def products_list():
    store = get_store_settings()
    user_id = get_current_user_id()
    
    # Search/filter
    q = (request.args.get("q") or "").strip().lower()
    stock_status = (request.args.get("stock_status") or "").strip()
    
    query = Product.query.filter_by(user_id=user_id)
    
    if q:
        query = query.filter(
            db.or_(
                Product.name.ilike(f"%{q}%"),
                Product.sku.ilike(f"%{q}%"),
                Product.barcode.ilike(f"%{q}%"),
            )
        )
    
    if stock_status == "low":
        query = query.filter(Product.stock_quantity <= Product.min_stock_level)
    elif stock_status == "in_stock":
        query = query.filter(Product.stock_quantity > 0)
    
    products = query.order_by(Product.name).all()
    
    return render_template("products_list.html", store=store, products=products)


@app.route("/products/new", methods=["GET", "POST"])
@login_required
def product_new():
    store = get_store_settings()
    if request.method == "POST":
        try:
            create_product(request.form)
            flash("Product created.", "success")
            return redirect(url_for("products_list"))
        except Exception as e:
            flash(f"Failed to create product: {e}", "error")
    
    return render_template("product_form.html", store=store, product=None)


@app.route("/products/<int:product_id>/edit", methods=["GET", "POST"])
@login_required
def product_edit(product_id: int):
    store = get_store_settings()
    product = find_product(product_id)
    
    if not product:
        flash("Product not found.", "error")
        return redirect(url_for("products_list"))
    
    if request.method == "POST":
        try:
            update_product(product, request.form)
            flash("Product updated.", "success")
            return redirect(url_for("products_list"))
        except Exception as e:
            flash(f"Failed to update product: {e}", "error")
    
    return render_template("product_form.html", store=store, product=product)


@app.route("/products/<int:product_id>/barcode")
@login_required
def product_barcode(product_id: int):
    store = get_store_settings()
    product = find_product(product_id)
    
    if not product:
        flash("Product not found.", "error")
        return redirect(url_for("products_list"))
    
    return render_template("product_barcode.html", store=store, product=product)


@app.route("/products/<int:product_id>/delete", methods=["POST"])
@login_required
def product_delete(product_id: int):
    product = find_product(product_id)
    
    if not product:
        flash("Product not found.", "error")
    else:
        db.session.delete(product)
        db.session.commit()
        flash("Product deleted.", "success")
    
    return redirect(url_for("products_list"))




@app.route("/inventory")
@login_required
def inventory_dashboard():
    store = get_store_settings()
    user_id = get_current_user_id()
    products = Product.query.filter_by(user_id=user_id).all()
    
    total_products = len(products)
    total_stock_qty = 0.0
    total_stock_value_selling = 0.0
    total_stock_value_cost = 0.0
    low_stock_products = []
    
    for p in products:
        total_stock_qty += p.stock_quantity
        total_stock_value_selling += p.stock_quantity * p.unit_price
        total_stock_value_cost += p.stock_quantity * p.cost_price
        
        if p.stock_quantity <= p.min_stock_level:
            low_stock_products.append(p)
    
    recent_txs = StockTransaction.query.filter_by(user_id=user_id).order_by(
        StockTransaction.date.desc()
    ).limit(20).all()
    
    summary = {
        "total_products": total_products,
        "total_stock_qty": total_stock_qty,
        "total_stock_value_selling": total_stock_value_selling,
        "total_stock_value_cost": total_stock_value_cost,
        "low_stock_products": low_stock_products,
        "recent_transactions": recent_txs,
    }
    
    return render_template("inventory_dashboard.html", store=store, summary=summary)


if __name__ == "__main__":
#AI GENERATED
    with app.app_context():
        db.create_all()
#AI GENERATED PART OVER

    app.run(debug=True, host="0.0.0.0", port=5000)
